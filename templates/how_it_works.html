{% extends "base.html" %}
{% block content %}
<div class="pagehead">
  <div>
    <h2 class="pagehead__title">How it Works</h2>
    <p class="pagehead__subtitle">Finite State Machine (FSM): budget vs spending â†’ state â†’ GIF.</p>
  </div>
</div>

<section class="grid grid--2">
  <div class="card">
    <div class="card__header">
      <h3 class="card__title">Interactive Flowchart</h3>
      <div class="card__subtitle">Click a step to learn what happens</div>
    </div>

    <div class="flow">
      <svg class="flow__svg" id="flow_svg" viewBox="0 0 827 420" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Budget Guardian FSM flowchart">
        <!-- JS draws nodes/edges -->
      </svg>

      <div class="flow__panel">
        <div class="flow__panelTitle" id="flow_title">Click a node</div>
        <div class="flow__panelBody" id="flow_body">This flowchart is the FSM logic only. Use the inputs on the right to see which decision path is taken and which state is chosen.</div>
      </div>
    </div>
  </div>

  <div class="card">
    <div class="card__header">
      <h3 class="card__title">Live FSM demo (plays the GIF)</h3>
      <div class="card__subtitle">Try different spend amounts</div>
    </div>

    <div class="grid grid--2 grid--tight">
      <div class="form__row">
        <label class="label" for="demo_budget">Budget (â‚±)</label>
        <input class="input" id="demo_budget" type="number" value="1000" min="0" step="0.01">
        <div class="help">FSM compares spending vs budget.</div>
      </div>

      <div class="form__row">
        <label class="label" for="demo_spent">Spent (â‚±)</label>
        <input class="input" id="demo_spent" type="number" value="0" min="0" step="0.01">
        <div class="help">Underspend &lt; 80% Â· On track â‰¤ 100% Â· Slight â‰¤ 105% Â· Major &gt; 105%</div>
      </div>
    </div>

    <div class="divider"></div>

    <div class="demo-fsm">
      <img class="demo-fsm__img" id="demo_pet_img" src="{{ url_for('static', filename='pet_images/' + pet_map['S0']) }}" alt="FSM demo pet" width="140" height="140">
      <div>
        <div class="muted">FSM result</div>
        <div class="demo-fsm__row">
          <span class="badge" id="demo_state">S0</span>
          <span class="demo-fsm__emoji" id="demo_emoji">ğŸ˜Š</span>
        </div>
        <div class="help" id="demo_explain">On track</div>
      </div>
    </div>

    <div class="divider"></div>

    <div class="card" style="background: rgba(255,255,255,0.02)">
      <div class="card__header" style="margin-bottom: 8px;">
        <h3 class="card__title">Demo dashboard (example)</h3>
        <div class="card__subtitle">This is not your real data</div>
      </div>

      <div class="grid grid--3" style="margin-bottom: 12px;">
        <div class="card stat" style="box-shadow:none; background: rgba(255,255,255,0.03)">
          <div class="stat__label">Daily budget</div>
          <div class="stat__value">â‚±<span id="demo_budget_card">1000.00</span></div>
        </div>
        <div class="card stat" style="box-shadow:none; background: rgba(255,255,255,0.03)">
          <div class="stat__label">Total expense (today)</div>
          <div class="stat__value stat__value--danger">â‚±<span id="demo_spent_card">0.00</span></div>
        </div>
        <div class="card stat" style="box-shadow:none; background: rgba(255,255,255,0.03)">
          <div class="stat__label">Pet mood</div>
          <div class="stat__value"><span id="demo_emoji_card">ğŸ˜Š</span></div>
        </div>
      </div>

      <div class="help">In the real Dashboard, the totals reset at midnight because it filters to â€œtodayâ€.</div>
    </div>
  </div>
</section>

<script>
(() => {
  // ---- Flowchart ----
  const svg = document.getElementById('flow_svg');
  const titleEl = document.getElementById('flow_title');
  const bodyEl = document.getElementById('flow_body');
  if (!svg || !titleEl || !bodyEl) return;

  // FSM-only flowchart (draw.io exported look):
  // Use the same grid-ish sizing/spacing as the provided draw.io diagram.
  const nodes = [
    // Left column
    { id: 'start', type: 'oval',   x: 70,  y: 10,  w: 120, h: 80, title: 'start', desc: 'Begin the FSM evaluation.' },
    { id: 'budget',type: 'rect',   x: 70,  y: 170, w: 120, h: 60, title: 'input budget', desc: 'Enter the budget (â‚±). This is the reference limit.' },
    { id: 'spent', type: 'rect',   x: 70,  y: 310, w: 120, h: 60, title: 'input spending', desc: 'Enter the spending (â‚±). This is what we compare against the budget.' },

    // Decision ladder (top -> bottom)
    { id: 'd80',   type: 'diamond',x: 374, y: 12,  w: 80,  h: 80, title: 'is spending < 80% of budget?', desc: 'YES â†’ S3. NO â†’ next decision.' },
    { id: 'd100',  type: 'diamond',x: 374, y: 112, w: 80,  h: 80, title: 'is spending â‰¤ 100% of budget?', desc: 'YES â†’ S0. NO â†’ next decision.' },
    { id: 'd105',  type: 'diamond',x: 374, y: 212, w: 80,  h: 80, title: 'is spending â‰¤ 105% of budget?', desc: 'YES â†’ S1. NO â†’ S2.' },

    // States column (same sizing as draw.io export)
    { id: 'S0',    type: 'state',  x: 600, y: 22,  w: 120, h: 60, title: 'S0', desc: 'On track: spending is within budget.' },
    { id: 'S1',    type: 'state',  x: 610, y: 122, w: 120, h: 60, title: 'S1', desc: 'Slight overspend: spending is up to 105% of budget.' },
    { id: 'S2',    type: 'state',  x: 610, y: 222, w: 120, h: 60, title: 'S2', desc: 'Major overspend: spending is over 105% of budget.' },
    { id: 'S3',    type: 'state',  x: 610, y: 322, w: 120, h: 60, title: 'S3', desc: 'Underspend: spending is under 80% of budget.' },
  ];

  // Edges with explicit anchor sides (orthogonal, draw.io-like).
  const edges = [
    { from: 'start',  to: 'budget', sideFrom: 'bottom', sideTo: 'top' },
    { from: 'budget', to: 'spent',  sideFrom: 'bottom', sideTo: 'top' },
    { from: 'spent',  to: 'd80',    sideFrom: 'right',  sideTo: 'left' },

    { from: 'd80',    to: 'S3',     sideFrom: 'right',  sideTo: 'left',  label: 'YES' },
    { from: 'd80',    to: 'd100',   sideFrom: 'bottom', sideTo: 'top',   label: 'NO' },

    { from: 'd100',   to: 'S0',     sideFrom: 'right',  sideTo: 'left',  label: 'YES' },
    { from: 'd100',   to: 'd105',   sideFrom: 'bottom', sideTo: 'top',   label: 'NO' },

    { from: 'd105',   to: 'S1',     sideFrom: 'right',  sideTo: 'left',  label: 'YES' },
    { from: 'd105',   to: 'S2',     sideFrom: 'bottom', sideTo: 'left',  label: 'NO' },
  ];

  const NS = 'http://www.w3.org/2000/svg';
  const mk = (name, attrs={}) => {
    const el = document.createElementNS(NS, name);
    for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  };

  // defs (arrow)
  const defs = mk('defs');
  const marker = mk('marker', { id:'arrow', viewBox:'0 0 10 10', refX:'9', refY:'5', markerWidth:'8', markerHeight:'8', orient:'auto-start-reverse' });
  marker.appendChild(mk('path', { d:'M 0 0 L 10 5 L 0 10 z', fill:'rgba(255,255,255,0.85)' }));
  defs.appendChild(marker);
  svg.appendChild(defs);

  const center = (n) => ({ cx: n.x + n.w / 2, cy: n.y + n.h / 2 });

  const anchorPoint = (node, side) => {
    // Explicit side anchors make the diagram deterministic & clean.
    if (node.type === 'diamond') {
      if (side === 'left') return { x: node.x, y: node.y + node.h / 2 };
      if (side === 'right') return { x: node.x + node.w, y: node.y + node.h / 2 };
      if (side === 'top') return { x: node.x + node.w / 2, y: node.y };
      if (side === 'bottom') return { x: node.x + node.w / 2, y: node.y + node.h };
    }

    if (node.type === 'oval') {
      if (side === 'left') return { x: node.x, y: node.y + node.h / 2 };
      if (side === 'right') return { x: node.x + node.w, y: node.y + node.h / 2 };
      if (side === 'top') return { x: node.x + node.w / 2, y: node.y };
      if (side === 'bottom') return { x: node.x + node.w / 2, y: node.y + node.h };
    }

    // rect/state fallback
    if (side === 'left') return { x: node.x, y: node.y + node.h / 2 };
    if (side === 'right') return { x: node.x + node.w, y: node.y + node.h / 2 };
    if (side === 'top') return { x: node.x + node.w / 2, y: node.y };
    if (side === 'bottom') return { x: node.x + node.w / 2, y: node.y + node.h };
    return center(node);
  };

  const orthoPath = (s, t, sideFrom, sideTo) => {
    // Draw.io-like orthogonal routing: stub out, then 1-2 bends, then stub in.
    const stub = 22;
    const outDir = (side) => {
      if (side === 'right') return { x: 1, y: 0 };
      if (side === 'left') return { x: -1, y: 0 };
      if (side === 'bottom') return { x: 0, y: 1 };
      if (side === 'top') return { x: 0, y: -1 };
      return { x: 0, y: 0 };
    };

    const d1 = outDir(sideFrom);
    const d2 = outDir(sideTo);

    const p0 = { x: s.x, y: s.y };
    const p1 = { x: s.x + d1.x * stub, y: s.y + d1.y * stub };
    const p3 = { x: t.x + d2.x * stub, y: t.y + d2.y * stub };
    const p4 = { x: t.x, y: t.y };

    // Choose routing axis based on the source exit direction.
    const horizFirst = (sideFrom === 'left' || sideFrom === 'right');
    const p2 = horizFirst ? { x: p3.x, y: p1.y } : { x: p1.x, y: p3.y };

    // Build path segments (avoid zero-length segments)
    const pts = [p0, p1, p2, p3, p4].filter((p, idx, arr) => {
      if (idx === 0) return true;
      const prev = arr[idx - 1];
      return !(Math.abs(prev.x - p.x) < 0.1 && Math.abs(prev.y - p.y) < 0.1);
    });

    return pts.reduce((d, p, idx) => d + (idx === 0 ? `M ${p.x} ${p.y}` : ` L ${p.x} ${p.y}`), '');
  };

  const labelPos = (fromNode, toNode, sideFrom, sideTo) => {
    // Place YES/NO similar to the draw.io export: near the branch, not the midpoint.
    const fx = fromNode.x + fromNode.w / 2;
    const fy = fromNode.y + fromNode.h / 2;
    const tx = toNode.x + toNode.w / 2;
    const ty = toNode.y + toNode.h / 2;
    const horiz = Math.abs(tx - fx) >= Math.abs(ty - fy);

    // Downward (NO) between diamonds
    if (!horiz && sideFrom === 'bottom' && sideTo === 'top') {
      return { x: fx, y: (fromNode.y + fromNode.h + toNode.y) / 2 - 6 };
    }

    // Rightward (YES) into state boxes
    if (horiz && sideFrom === 'right' && sideTo === 'left') {
      return { x: fromNode.x + fromNode.w + 26, y: fromNode.y + fromNode.h / 2 - 8 };
    }

    // Fallback
    return { x: (fx + tx) / 2, y: (fy + ty) / 2 - 10 };
  };

  // edges (with optional YES/NO labels)
  const edgeLayer = mk('g', { class:'flow__edges' });
  const edgeEls = new Map();
  for (const e of edges) {
    const na = nodes.find(n => n.id === e.from);
    const nb = nodes.find(n => n.id === e.to);
    if (!na || !nb) continue;

    const s = anchorPoint(na, e.sideFrom);
    const t = anchorPoint(nb, e.sideTo);
    const path = mk('path', {
      class: 'flow__edge',
      d: orthoPath(s, t, e.sideFrom, e.sideTo),
      fill: 'none',
      'marker-end': 'url(#arrow)'
    });
    edgeLayer.appendChild(path);
    edgeEls.set(`${e.from}->${e.to}`, path);

    if (e.label) {
      const pos = labelPos(na, nb, e.sideFrom, e.sideTo);
      const label = mk('text', { x: pos.x, y: pos.y, class: 'flow__edgeLabel', 'text-anchor': 'middle' });
      label.textContent = e.label;
      edgeLayer.appendChild(label);
    }
  }
  svg.appendChild(edgeLayer);

  // nodes
  const nodeLayer = mk('g', { class:'flow__nodes' });
  const nodeEls = new Map();
  for (const n of nodes) {
    const g = mk('g', { class:'flow__node', tabindex:'0', 'data-id':n.id });

    // shape
    if (n.type === 'diamond') {
      const cx = n.x + n.w / 2;
      const cy = n.y + n.h / 2;
      const pts = [
        `${cx} ${n.y}`,                    // top
        `${n.x + n.w} ${cy}`,              // right
        `${cx} ${n.y + n.h}`,              // bottom
        `${n.x} ${cy}`,                    // left
      ].join(' ');
      g.appendChild(mk('polygon', { points: pts, class: 'flow__diamond' }));
    } else if (n.type === 'oval') {
      g.appendChild(mk('ellipse', { cx: n.x + n.w/2, cy: n.y + n.h/2, rx: n.w/2, ry: n.h/2, class: 'flow__oval' }));
    } else {
      // draw.io rounded rects
      g.appendChild(mk('rect', { x:n.x, y:n.y, width:n.w, height:n.h, rx:'10', class: 'flow__rect' }));
    }

    // text (wrap-ish: split into 2 lines if too long)
    const lines = [];
    if (n.type === 'diamond') {
      // short-wrap diamond text
      const parts = n.title.split(' ');
      let cur = '';
      for (const p of parts) {
        const next = (cur ? cur + ' ' : '') + p;
        if (next.length > 18 && cur) { lines.push(cur); cur = p; } else { cur = next; }
      }
      if (cur) lines.push(cur);
    } else {
      lines.push(n.title);
    }

    const text = mk('text', { class: 'flow__text' });
    if (n.type === 'diamond') {
      // center + wrap for diamonds
      text.setAttribute('x', String(n.x + n.w / 2));
      text.setAttribute('text-anchor', 'middle');
      const startY = n.y + 28;
      lines.slice(0, 3).forEach((ln, idx) => {
        const tsp = mk('tspan', { x: n.x + n.w / 2, y: startY + idx * 16 });
        tsp.textContent = ln;
        text.appendChild(tsp);
      });
    } else {
      // draw.io centers text in shapes
      text.setAttribute('x', String(n.x + n.w / 2));
      text.setAttribute('y', String(n.y + n.h / 2 + 6));
      text.setAttribute('text-anchor', 'middle');
      text.textContent = lines[0];
    }

    g.appendChild(text);
    nodeLayer.appendChild(g);
    nodeEls.set(n.id, g);

    const activate = () => {
      for (const el of nodeEls.values()) el.classList.remove('is-active');
      g.classList.add('is-active');
      titleEl.textContent = n.title;
      bodyEl.textContent = n.desc;
    };

    g.addEventListener('click', activate);
    g.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        activate();
      }
    });
  }
  svg.appendChild(nodeLayer);

  // Default selection
  nodeEls.get('start')?.dispatchEvent(new Event('click'));

  const clearHighlights = () => {
    for (const el of nodeEls.values()) {
      el.classList.remove('is-path');
      el.classList.remove('is-input');
      el.classList.remove('is-state');
    }
    for (const el of edgeEls.values()) el.classList.remove('is-path');
  };

  const setPath = (ids, edgePairs=[]) => {
    clearHighlights();
    for (const id of ids) nodeEls.get(id)?.classList.add('is-path');
    for (const [a,b] of edgePairs) edgeEls.get(`${a}->${b}`)?.classList.add('is-path');
  };

  // ---- FSM demo ----
  const petMap = {
    S0: "{{ url_for('static', filename='pet_images/' + pet_map['S0']) }}",
    S1: "{{ url_for('static', filename='pet_images/' + pet_map['S1']) }}",
    S2: "{{ url_for('static', filename='pet_images/' + pet_map['S2']) }}",
    S3: "{{ url_for('static', filename='pet_images/' + pet_map['S3']) }}",
  };

  const budgetInput = document.getElementById('demo_budget');
  const spentInput = document.getElementById('demo_spent');
  const budgetRow = budgetInput?.closest('.form__row');
  const spentRow = spentInput?.closest('.form__row');
  const img = document.getElementById('demo_pet_img');
  const stateEl = document.getElementById('demo_state');
  const emojiEl = document.getElementById('demo_emoji');
  const explainEl = document.getElementById('demo_explain');
  const budgetCard = document.getElementById('demo_budget_card');
  const spentCard = document.getElementById('demo_spent_card');
  const emojiCard = document.getElementById('demo_emoji_card');

  const fmt = (n) => (Number.isFinite(n) ? n.toFixed(2) : '0.00');
  let inputFocus = null; // 'budget' | 'spent' | null

  const activateNodeById = (id) => {
    const n = nodes.find(x => x.id === id);
    const g = nodeEls.get(id);
    if (!n || !g) return;
    for (const el of nodeEls.values()) el.classList.remove('is-active');
    g.classList.add('is-active');
    titleEl.textContent = n.title;
    bodyEl.textContent = n.desc;
  };

  const setLinkedRow = (which) => {
    budgetRow?.classList.toggle('is-linked', which === 'budget');
    spentRow?.classList.toggle('is-linked', which === 'spent');
  };

  const compute = () => {
    const budget = Math.max(0, parseFloat(budgetInput.value || '0'));
    const spent = Math.max(0, parseFloat(spentInput.value || '0'));

    let state = 'S0';
    if (budget <= 0) {
      state = spent > 0 ? 'S2' : 'S0';
    } else if (spent < 0.8 * budget) {
      state = 'S3';
    } else if (spent <= budget) {
      state = 'S0';
    } else if (spent <= 1.05 * budget) {
      state = 'S1';
    } else {
      state = 'S2';
    }

    const meta = {
      S0: { emoji: 'ğŸ˜Š', label: 'On track' },
      S1: { emoji: 'ğŸ˜Ÿ', label: 'Slight overspend' },
      S2: { emoji: 'ğŸ˜¢', label: 'Major overspend' },
      S3: { emoji: 'ğŸ˜º', label: 'Underspend / saving' },
    }[state];

    img.src = petMap[state];
    stateEl.textContent = state;
    emojiEl.textContent = meta.emoji;
    explainEl.textContent = meta.label;

    // demo dashboard cards
    budgetCard.textContent = fmt(budget);
    spentCard.textContent = fmt(spent);
    emojiCard.textContent = meta.emoji;

    stateEl.className = 'badge ' + (state === 'S0' || state === 'S3' ? 'badge--good' : 'badge--danger');

    // Flowchart highlighting (FSM-only)
    const base = ['start', 'budget', 'spent'];
    let path = [];
    let edgesOn = [['start','budget'],['budget','spent'],['spent','d80']];

    if (state === 'S3') {
      path = [...base, 'd80', 'S3'];
      edgesOn = [...edgesOn, ['d80','S3']];
    } else if (state === 'S0') {
      path = [...base, 'd80', 'd100', 'S0'];
      edgesOn = [...edgesOn, ['d80','d100'], ['d100','S0']];
    } else if (state === 'S1') {
      path = [...base, 'd80', 'd100', 'd105', 'S1'];
      edgesOn = [...edgesOn, ['d80','d100'], ['d100','d105'], ['d105','S1']];
    } else {
      path = [...base, 'd80', 'd100', 'd105', 'S2'];
      edgesOn = [...edgesOn, ['d80','d100'], ['d100','d105'], ['d105','S2']];
    }

    setPath(path, edgesOn);

    // Highlight currently interacted input node
    if (inputFocus === 'budget') nodeEls.get('budget')?.classList.add('is-input');
    if (inputFocus === 'spent') nodeEls.get('spent')?.classList.add('is-input');

    // Highlight resulting state box
    nodeEls.get(state)?.classList.add('is-state');

    // Keep the right-hand inputs visually â€œlinkedâ€ to the flowchart
    setLinkedRow(inputFocus);
  };

  const setFocus = (which) => {
    inputFocus = which;
    if (which === 'budget') activateNodeById('budget');
    if (which === 'spent') activateNodeById('spent');
    if (which === null) activateNodeById('start');
    compute();
  };

  // Input -> flowchart
  budgetInput.addEventListener('focus', () => setFocus('budget'));
  spentInput.addEventListener('focus', () => setFocus('spent'));
  budgetInput.addEventListener('blur', () => setFocus(null));
  spentInput.addEventListener('blur', () => setFocus(null));
  budgetInput.addEventListener('input', () => setFocus('budget'));
  spentInput.addEventListener('input', () => setFocus('spent'));

  // Flowchart -> input (click the flow nodes)
  const focusInputForNode = (id) => {
    if (id === 'budget') { budgetInput?.focus(); budgetInput?.select?.(); }
    if (id === 'spent') { spentInput?.focus(); spentInput?.select?.(); }
  };

  nodeEls.get('budget')?.addEventListener('click', () => focusInputForNode('budget'));
  nodeEls.get('spent')?.addEventListener('click', () => focusInputForNode('spent'));

  compute();
})();
</script>
{% endblock %}
